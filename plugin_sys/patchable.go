package plugin_sys

import (
	"fmt"
	"reflect"
	"runtime"
)

type PatchableType struct {
	ptrTp   reflect.Type
	fnSlots map[string]reflect.Value
}

func NewPatchable[T any](_ T) (*PatchableType, *T) {
	fnTbPtr := reflect.New(reflect.TypeOf((*T)(nil)).Elem())
	fnTb := fnTbPtr.Elem()
	fnTbTp := fnTb.Type()

	r := &PatchableType{
		fnSlots: map[string]reflect.Value{},
		ptrTp:   fnTbTp.Field(0).Type.In(0),
	}

	for i := 0; i < fnTbTp.NumField(); i++ {
		f := fnTbTp.Field(i)
		if f.Type.Kind() != reflect.Func {
			panic(fmt.Errorf("%s field is not function, %s", r.ptrTp, f.Name))
		} else if f.Type.In(0) != r.ptrTp {
			panic(fmt.Errorf("receiver type incorret, func %s, need %s, got %s", f.Name, r.ptrTp, f.Type.In(0)))
		}
		r.fnSlots[f.Name] = fnTb.Field(i).Addr()
	}

	return r, fnTbPtr.Interface().(*T)
}

func (pt *PatchableType) Patch(newPatchPtr any) {
	patchPtrTp := reflect.TypeOf(newPatchPtr)
	pt.checkPatchTp(patchPtrTp)
	for name := range pt.fnSlots {
		origFn, _ := pt.ptrTp.MethodByName(name)
		newFn, _ := patchPtrTp.MethodByName(origFn.Name)
		pt.fnSlots[origFn.Name].Elem().Set(reinterpretedCast(origFn.Type, newFn.Func))
	}
}

func (pt *PatchableType) checkPatchTp(patchPtrTp reflect.Type) {
	patch := patchPtrTp.Elem()
	orig := pt.ptrTp.Elem()
	embeddedTp := patch.Field(0).Type

	if patch.Size() != orig.Size() {
		panic(fmt.Errorf("patch type must not have extra fields, %s", patch))
	}
	if embeddedTp != orig {
		panic(fmt.Errorf("patch type must embed orig type as first elem, orig: %s, patch: %s, first elem: %s", orig, patch, embeddedTp))
	}

	for name := range pt.fnSlots {
		origFn, ok := pt.ptrTp.MethodByName(name)
		if !ok {
			panic(fmt.Errorf("%s method not found %s", pt.ptrTp, name))
		}
		newFn, ok := patchPtrTp.MethodByName(origFn.Name)
		if ok && !isPromotedMethod(newFn.Func) {
			if err := pt.checkFnSig(origFn.Type, newFn.Func.Type()); err != nil {
				panic(fmt.Errorf("%s method %s, %w", pt.ptrTp, origFn.Name, err))
			}
		} else {
			panic(fmt.Errorf("%s method has no patch: %s", pt.ptrTp, origFn.Name))
		}
	}
}

func (pt *PatchableType) checkFnSig(to, from reflect.Type) error {
	if from.NumIn() != to.NumIn() {
		return fmt.Errorf("input param count mismatch, orig: %v, patch: %v", to.NumIn(), from.NumIn())
	}
	if from.NumOut() != to.NumOut() {
		return fmt.Errorf("output param count mismatch, orig: %v, patch: %v", to.NumOut(), from.NumOut())
	}
	for i := 0; i < from.NumIn(); i++ {
		patch := from.In(i)
		orig := to.In(i)
		if i == 0 {
			if patch.Elem().Field(0).Type != orig.Elem() {
				return fmt.Errorf("receiver not compatible, orig: %s, patch: %s", orig, patch)
			}
		} else if patch != orig {
			return fmt.Errorf("input param type mismatch, orig: %s, patch: %s", orig, patch)
		}
	}
	for i := 0; i < from.NumOut(); i++ {
		orig := to.Out(i)
		patch := from.Out(i)
		if orig != patch {
			return fmt.Errorf("output param type mismatch, orig: %s, path: %s", orig, patch)
		}
	}
	return nil
}

func reinterpretedCast(dst reflect.Type, src reflect.Value) (ret reflect.Value) {
	ret = reflect.New(dst)
	reflect.NewAt(src.Type(), ret.UnsafePointer()).Elem().Set(src)
	return ret.Elem()
}

func isPromotedMethod(f reflect.Value) bool {
	if f.Kind() != reflect.Func {
		return false
	}
	fn := runtime.FuncForPC(f.Pointer())
	fName, _ := fn.FileLine(fn.Entry())
	return fName == "<autogenerated>"
}

type inner struct{}

type outer struct {
	inner
}

func (*inner) Foo() {}

func init() {
	if !isPromotedMethod(reflect.TypeOf((*outer)(nil)).Method(0).Func) {
		panic("isPromotedMethod not work")
	}
}
